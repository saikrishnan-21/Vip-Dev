# VIP-10212: Generation Job Management System

**Story ID**: VIP-10212
**Story Type**: Story
**Epic**: E3-Content-Generation-(AI)
**Priority**: Medium
**Story Points**: 5
**Status**: To Do

## User Story

As a content creator, I want to manage my generation jobs (view history, retry failed jobs, cancel running jobs) so that I have full control over my content generation workflow and can recover from failures

## Acceptance Criteria

- [ ] **AC1**: View generation job history with filtering (status, date, mode)
- [ ] **AC2**: Retry failed generation jobs with same parameters
- [ ] **AC3**: Cancel running or queued jobs
- [ ] **AC4**: Delete completed jobs from history
- [ ] **AC5**: View job details (parameters, results, errors)
- [ ] **AC6**: Bulk operations (retry all failed, cancel all queued)
- [ ] **AC7**: Job history pagination (50 jobs per page)

## Technical Details

**Architecture:**
- **FastAPI Role**: No direct involvement (all job management in Next.js)
- **Next.js Role**: CRUD operations on generation_jobs collection, job orchestration
- **Data Flow**: Browser → Next.js API → MongoDB (generation_jobs)

**Job Management Workflow:**

```
Job History Page (Next.js):
GET /api/jobs
  → Fetch jobs from MongoDB with filters
  → Paginated list (50 per page)
  → Status: queued, processing, completed, failed, cancelled
    ↓
Job Details View:
GET /api/jobs/{id}
  → Full job parameters
  → Generated content (if completed)
  → Error details (if failed)
  → Progress history
    ↓
Retry Failed Job:
POST /api/jobs/{id}/retry
  → Copy job parameters
  → Create new job with status: queued
  → Call FastAPI with same parameters
    ↓
Cancel Job:
POST /api/jobs/{id}/cancel
  → Update status to 'cancelled'
  → Stop FastAPI processing (if running)
    ↓
Delete Job:
DELETE /api/jobs/{id}
  → Remove from MongoDB
  → Cannot delete running jobs
```

**Next.js API Routes (NEW):**

```typescript
// app/api/jobs/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { getDb } from '@/lib/mongodb';
import { ObjectId } from 'mongodb';

/**
 * GET /api/jobs
 * List user's generation jobs with filtering and pagination
 */
export async function GET(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const searchParams = request.nextUrl.searchParams;
  const status = searchParams.get('status'); // queued, processing, completed, failed, cancelled
  const mode = searchParams.get('mode'); // topic, keywords, trends, spin
  const page = parseInt(searchParams.get('page') || '1');
  const limit = 50;
  const skip = (page - 1) * limit;

  const db = await getDb();

  // Build filter
  const filter: any = {
    userId: new ObjectId(session.user.id)
  };

  if (status) {
    filter.status = status;
  }

  if (mode) {
    filter.mode = mode;
  }

  // Fetch jobs
  const [jobs, total] = await Promise.all([
    db.collection('generation_jobs')
      .find(filter)
      .sort({ created_at: -1 })
      .skip(skip)
      .limit(limit)
      .toArray(),
    db.collection('generation_jobs').countDocuments(filter)
  ]);

  return NextResponse.json({
    jobs,
    pagination: {
      page,
      limit,
      total,
      pages: Math.ceil(total / limit)
    }
  });
}
```

```typescript
// app/api/jobs/[id]/route.ts
import { NextRequest, NextResponse } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';
import { getDb } from '@/lib/mongodb';
import { ObjectId } from 'mongodb';

/**
 * GET /api/jobs/{id}
 * Get job details
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const db = await getDb();
  const job = await db.collection('generation_jobs').findOne({
    _id: new ObjectId(params.id),
    userId: new ObjectId(session.user.id)
  });

  if (!job) {
    return NextResponse.json({ error: 'Job not found' }, { status: 404 });
  }

  return NextResponse.json({ job });
}

/**
 * DELETE /api/jobs/{id}
 * Delete completed or failed job
 */
export async function DELETE(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const db = await getDb();
  const job = await db.collection('generation_jobs').findOne({
    _id: new ObjectId(params.id),
    userId: new ObjectId(session.user.id)
  });

  if (!job) {
    return NextResponse.json({ error: 'Job not found' }, { status: 404 });
  }

  // Cannot delete running jobs
  if (['queued', 'processing'].includes(job.status)) {
    return NextResponse.json(
      { error: 'Cannot delete running jobs. Cancel first.' },
      { status: 400 }
    );
  }

  await db.collection('generation_jobs').deleteOne({
    _id: new ObjectId(params.id)
  });

  return NextResponse.json({ success: true, message: 'Job deleted' });
}
```

```typescript
// app/api/jobs/[id]/retry/route.ts
/**
 * POST /api/jobs/{id}/retry
 * Retry failed generation job
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const db = await getDb();
  const originalJob = await db.collection('generation_jobs').findOne({
    _id: new ObjectId(params.id),
    userId: new ObjectId(session.user.id)
  });

  if (!originalJob) {
    return NextResponse.json({ error: 'Job not found' }, { status: 404 });
  }

  // Only retry failed or cancelled jobs
  if (!['failed', 'cancelled'].includes(originalJob.status)) {
    return NextResponse.json(
      { error: 'Can only retry failed or cancelled jobs' },
      { status: 400 }
    );
  }

  // Create new job with same parameters
  const newJob = {
    userId: originalJob.userId,
    bulk_job_id: originalJob.bulk_job_id,
    mode: originalJob.mode,
    topic: originalJob.topic,
    keywords: originalJob.keywords,
    word_count: originalJob.word_count,
    tone: originalJob.tone,
    status: 'queued',
    progress: {
      percentage: 0,
      stage: 'queued',
      stage_progress: 0,
      message: 'Queued for generation...',
      started_at: null,
      completed_at: null,
      estimated_completion: null,
      elapsed_seconds: 0
    },
    created_at: new Date(),
    updated_at: new Date()
  };

  const result = await db.collection('generation_jobs').insertOne(newJob);

  // Call FastAPI to start generation
  await fetch(`${process.env.FASTAPI_URL}/api/content/generate/${originalJob.mode}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      mode: originalJob.mode,
      topic: originalJob.topic,
      keywords: originalJob.keywords,
      word_count: originalJob.word_count,
      tone: originalJob.tone,
      job_id: result.insertedId.toString(),
      user_id: session.user.id
    })
  });

  return NextResponse.json({
    success: true,
    new_job_id: result.insertedId.toString(),
    message: 'Job queued for retry'
  });
}
```

```typescript
// app/api/jobs/[id]/cancel/route.ts
/**
 * POST /api/jobs/{id}/cancel
 * Cancel queued or running job
 */
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const db = await getDb();
  const job = await db.collection('generation_jobs').findOne({
    _id: new ObjectId(params.id),
    userId: new ObjectId(session.user.id)
  });

  if (!job) {
    return NextResponse.json({ error: 'Job not found' }, { status: 404 });
  }

  // Can only cancel queued or processing jobs
  if (!['queued', 'processing'].includes(job.status)) {
    return NextResponse.json(
      { error: 'Can only cancel queued or processing jobs' },
      { status: 400 }
    );
  }

  // Update job status to cancelled
  await db.collection('generation_jobs').updateOne(
    { _id: new ObjectId(params.id) },
    {
      $set: {
        status: 'cancelled',
        'progress.message': 'Cancelled by user',
        'progress.completed_at': new Date(),
        updated_at: new Date()
      }
    }
  );

  // If job is processing, FastAPI will detect cancellation and stop
  // (via periodic status checks in ProgressTracker)

  return NextResponse.json({ success: true, message: 'Job cancelled' });
}
```

```typescript
// app/api/jobs/bulk-operations/route.ts
/**
 * POST /api/jobs/bulk-operations
 * Bulk operations on jobs (retry all failed, cancel all queued)
 */
export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  const { operation } = await request.json();
  const db = await getDb();

  if (operation === 'retry_all_failed') {
    // Get all failed jobs
    const failedJobs = await db.collection('generation_jobs')
      .find({
        userId: new ObjectId(session.user.id),
        status: 'failed'
      })
      .toArray();

    const newJobIds: string[] = [];

    for (const failedJob of failedJobs) {
      // Create new job for each failed one
      const newJob = {
        userId: failedJob.userId,
        bulk_job_id: failedJob.bulk_job_id,
        mode: failedJob.mode,
        topic: failedJob.topic,
        keywords: failedJob.keywords,
        word_count: failedJob.word_count,
        tone: failedJob.tone,
        status: 'queued',
        progress: {
          percentage: 0,
          stage: 'queued',
          stage_progress: 0,
          message: 'Queued for retry...',
          started_at: null,
          completed_at: null,
          estimated_completion: null,
          elapsed_seconds: 0
        },
        created_at: new Date(),
        updated_at: new Date()
      };

      const result = await db.collection('generation_jobs').insertOne(newJob);
      newJobIds.push(result.insertedId.toString());

      // Queue each job
      await fetch(`${process.env.FASTAPI_URL}/api/content/generate/${failedJob.mode}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          mode: failedJob.mode,
          topic: failedJob.topic,
          keywords: failedJob.keywords,
          word_count: failedJob.word_count,
          tone: failedJob.tone,
          job_id: result.insertedId.toString(),
          user_id: session.user.id
        })
      });
    }

    return NextResponse.json({
      success: true,
      message: `${newJobIds.length} failed jobs queued for retry`,
      new_job_ids: newJobIds
    });

  } else if (operation === 'cancel_all_queued') {
    // Cancel all queued jobs
    const result = await db.collection('generation_jobs').updateMany(
      {
        userId: new ObjectId(session.user.id),
        status: 'queued'
      },
      {
        $set: {
          status: 'cancelled',
          'progress.message': 'Cancelled by user (bulk operation)',
          'progress.completed_at': new Date(),
          updated_at: new Date()
        }
      }
    );

    return NextResponse.json({
      success: true,
      message: `${result.modifiedCount} queued jobs cancelled`
    });

  } else {
    return NextResponse.json(
      { error: 'Invalid operation' },
      { status: 400 }
    );
  }
}
```

**Job History UI Component (`components/job-history-table.tsx` - NEW):**

```typescript
'use client';

import { useState, useEffect } from 'react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { RotateCw, X, Trash2, Eye } from 'lucide-react';
import { formatDistanceToNow } from 'date-fns';

export function JobHistoryTable() {
  const [jobs, setJobs] = useState([]);
  const [loading, setLoading] = useState(true);
  const [page, setPage] = useState(1);
  const [total, setTotal] = useState(0);

  useEffect(() => {
    fetchJobs();
  }, [page]);

  const fetchJobs = async () => {
    setLoading(true);
    const response = await fetch(`/api/jobs?page=${page}`);
    const data = await response.json();
    setJobs(data.jobs);
    setTotal(data.pagination.total);
    setLoading(false);
  };

  const handleRetry = async (jobId: string) => {
    const response = await fetch(`/api/jobs/${jobId}/retry`, {
      method: 'POST'
    });
    if (response.ok) {
      fetchJobs(); // Refresh list
    }
  };

  const handleCancel = async (jobId: string) => {
    const response = await fetch(`/api/jobs/${jobId}/cancel`, {
      method: 'POST'
    });
    if (response.ok) {
      fetchJobs();
    }
  };

  const handleDelete = async (jobId: string) => {
    if (confirm('Delete this job? This cannot be undone.')) {
      const response = await fetch(`/api/jobs/${jobId}`, {
        method: 'DELETE'
      });
      if (response.ok) {
        fetchJobs();
      }
    }
  };

  const getStatusBadge = (status: string) => {
    const variants: Record<string, any> = {
      completed: 'default',
      processing: 'secondary',
      queued: 'outline',
      failed: 'destructive',
      cancelled: 'secondary'
    };
    return <Badge variant={variants[status] || 'outline'}>{status}</Badge>;
  };

  return (
    <div>
      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Mode</TableHead>
            <TableHead>Topic/Keywords</TableHead>
            <TableHead>Status</TableHead>
            <TableHead>Created</TableHead>
            <TableHead>Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {jobs.map((job: any) => (
            <TableRow key={job._id}>
              <TableCell className="capitalize">{job.mode}</TableCell>
              <TableCell className="max-w-xs truncate">
                {job.topic || job.keywords?.join(', ') || 'N/A'}
              </TableCell>
              <TableCell>{getStatusBadge(job.status)}</TableCell>
              <TableCell className="text-sm text-muted-foreground">
                {formatDistanceToNow(new Date(job.created_at), { addSuffix: true })}
              </TableCell>
              <TableCell className="space-x-2">
                <Button size="sm" variant="ghost" onClick={() => window.location.href = `/dashboard/jobs/${job._id}`}>
                  <Eye className="h-4 w-4" />
                </Button>

                {job.status === 'failed' && (
                  <Button size="sm" variant="ghost" onClick={() => handleRetry(job._id)}>
                    <RotateCw className="h-4 w-4" />
                  </Button>
                )}

                {['queued', 'processing'].includes(job.status) && (
                  <Button size="sm" variant="ghost" onClick={() => handleCancel(job._id)}>
                    <X className="h-4 w-4" />
                  </Button>
                )}

                {['completed', 'failed', 'cancelled'].includes(job.status) && (
                  <Button size="sm" variant="ghost" onClick={() => handleDelete(job._id)}>
                    <Trash2 className="h-4 w-4" />
                  </Button>
                )}
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>

      {/* Pagination */}
      <div className="flex justify-between items-center mt-4">
        <p className="text-sm text-muted-foreground">{total} total jobs</p>
        <div className="space-x-2">
          <Button
            size="sm"
            variant="outline"
            disabled={page === 1}
            onClick={() => setPage(page - 1)}
          >
            Previous
          </Button>
          <Button
            size="sm"
            variant="outline"
            disabled={page >= Math.ceil(total / 50)}
            onClick={() => setPage(page + 1)}
          >
            Next
          </Button>
        </div>
      </div>
    </div>
  );
}
```

## Definition of Done

- [ ] Next.js API route `/api/jobs` for listing jobs with filters
- [ ] Next.js API route `/api/jobs/{id}` for job details and delete
- [ ] Next.js API route `/api/jobs/{id}/retry` for retrying failed jobs
- [ ] Next.js API route `/api/jobs/{id}/cancel` for cancelling jobs
- [ ] Next.js API route `/api/jobs/bulk-operations` for bulk actions
- [ ] Job history UI component with table view
- [ ] Pagination (50 jobs per page)
- [ ] Status filtering (queued, processing, completed, failed, cancelled)
- [ ] Mode filtering (topic, keywords, trends, spin)
- [ ] Job details page with full parameters and results
- [ ] Retry button for failed jobs
- [ ] Cancel button for running jobs
- [ ] Delete button for completed jobs
- [ ] Bulk retry all failed jobs
- [ ] Bulk cancel all queued jobs
- [ ] Tests written for job management
- [ ] Code reviewed and approved
- [ ] Merged to dev branch

## Notes

**Implementation Status**: ⏳ Depends on VIP-10204-10211 (job creation and progress tracking)

**Job Management Features:**

**Job Listing:**
- Default: Show all jobs, newest first
- Filters: Status, mode, date range
- Pagination: 50 jobs per page
- Search: By topic or keywords (optional)

**Job Actions:**
- **View**: See full details, parameters, results, errors
- **Retry**: Create new job with same parameters (failed/cancelled only)
- **Cancel**: Stop processing or remove from queue (queued/processing only)
- **Delete**: Remove from history (completed/failed/cancelled only)

**Bulk Operations:**
- Retry all failed: Create new jobs for all failed ones
- Cancel all queued: Stop all jobs waiting in queue
- Delete all completed: Clean up old successful jobs

**Job Status Lifecycle:**
```
queued → processing → completed
                   ↘ failed

Actions by status:
- queued: Cancel, Delete
- processing: Cancel
- completed: Delete
- failed: Retry, Delete
- cancelled: Retry, Delete
```

**Performance Considerations:**
- Pagination prevents loading thousands of jobs
- Indexed queries on userId + status + created_at
- Bulk operations limited to 100 jobs at a time (safety)
- Delete cascades to generated_content if linked

**Storage Cleanup:**
- Auto-delete completed jobs after 30 days (optional cron)
- Keep failed jobs indefinitely for debugging
- Archive old jobs to separate collection (optional)

**Security:**
- All operations require authentication
- User can only manage their own jobs
- Cannot delete other users' jobs
- Bulk operations scoped to user's jobs only

**Future Enhancements:**
- Export job history to CSV
- Job templates (save parameters for reuse)
- Scheduled jobs (cron-based generation)
- Job statistics dashboard

**Final E3 Story**: This completes all 13 Epic E3 stories!
