# VIP-10211: Real-Time Progress Tracking System

**Story ID**: VIP-10211
**Story Type**: Story
**Epic**: E3-Content-Generation-(AI)
**Priority**: High
**Story Points**: 5
**Status**: To Do

## User Story

As a content creator, I want real-time progress updates for generation jobs so that I know the current status, remaining time, and can monitor bulk generation workflows without refreshing the page

## Acceptance Criteria

- [ ] **AC1**: Real-time job status updates (queued, processing, completed, failed)
- [ ] **AC2**: Progress percentage and stage tracking (research, writing, SEO)
- [ ] **AC3**: Estimated completion time based on current progress
- [ ] **AC4**: Live updates using Server-Sent Events (SSE) or WebSockets
- [ ] **AC5**: Bulk job progress (X of Y articles completed)
- [ ] **AC6**: Job failure detection with error messages
- [ ] **AC7**: Progress persistence in MongoDB for recovery

## Technical Details

**Architecture:**
- **FastAPI Role**: Emit progress events during generation, update job status in real-time
- **Next.js Role**: Receive SSE/WebSocket events, update UI, store progress in MongoDB
- **Data Flow**: FastAPI (progress events) → Next.js SSE → Browser (live UI updates)

**Progress Tracking Workflow:**

```
User starts generation (Next.js):
- Create job in MongoDB (status: queued)
- Return job_id to frontend
- Frontend opens SSE connection to /api/jobs/{job_id}/progress
    ↓
Next.js calls FastAPI /api/content/generate
    ↓
FastAPI starts generation:
  → Stage 1: Research (0-33% progress)
    - Update: "Researching topic..."
    - Event emitted to Next.js
  → Stage 2: Writing (33-66% progress)
    - Update: "Writing article..."
    - Event emitted to Next.js
  → Stage 3: SEO Optimization (66-100% progress)
    - Update: "Optimizing for SEO..."
    - Event emitted to Next.js
    ↓
Next.js receives progress events via SSE
    ↓
Next.js updates MongoDB job status
    ↓
Next.js sends SSE events to browser
    ↓
Frontend updates progress bar and status in real-time
    ↓
On completion: FastAPI → Next.js → Store final content → Close SSE connection
```

**MongoDB Job Schema Update:**

```typescript
// generation_jobs collection - enhance with progress fields
interface GenerationJob {
  _id: ObjectId;
  userId: ObjectId;
  bulk_job_id: ObjectId | null;
  mode: "topic" | "keywords" | "trends" | "spin";

  // Existing fields
  topic?: string;
  keywords?: string[];
  word_count: number;
  tone: string;

  // Progress tracking fields (NEW)
  status: "queued" | "processing" | "completed" | "failed" | "cancelled";
  progress: {
    percentage: number;          // 0-100
    stage: "research" | "writing" | "seo" | "completed";
    stage_progress: number;      // Progress within current stage (0-100)
    message: string;             // Human-readable status message
    started_at: Date | null;
    completed_at: Date | null;
    estimated_completion: Date | null;
    elapsed_seconds: number;
  };

  // Results
  result?: {
    content: string;
    meta_title: string;
    meta_description: string;
    word_count: number;
    seo_score: number;
    readability_score: number;
  };

  error?: {
    message: string;
    stage: string;
    timestamp: Date;
  };

  created_at: Date;
  updated_at: Date;
}
```

**FastAPI Progress Emitter (`services/progress_service.py` - NEW):**

```python
"""
Progress Tracking Service
Real-time job progress updates
"""

from typing import Optional, Dict, Callable
from datetime import datetime, timedelta
import asyncio
import logging

logger = logging.getLogger(__name__)


class ProgressTracker:
    """Tracks and emits progress updates for generation jobs"""

    def __init__(self, job_id: str, callback: Optional[Callable] = None):
        self.job_id = job_id
        self.callback = callback
        self.start_time = datetime.utcnow()
        self.current_stage = "queued"
        self.current_progress = 0.0

    async def update(
        self,
        stage: str,
        progress: float,
        message: str,
        stage_progress: Optional[float] = None
    ):
        """
        Update job progress and emit event

        Args:
            stage: Current stage (research, writing, seo, completed)
            progress: Overall progress (0-100)
            message: Human-readable status message
            stage_progress: Progress within current stage (0-100)
        """
        self.current_stage = stage
        self.current_progress = progress

        elapsed = (datetime.utcnow() - self.start_time).total_seconds()

        # Estimate completion time
        if progress > 0:
            estimated_total_seconds = (elapsed / progress) * 100
            estimated_remaining = estimated_total_seconds - elapsed
            estimated_completion = datetime.utcnow() + timedelta(seconds=estimated_remaining)
        else:
            estimated_completion = None

        progress_data = {
            "job_id": self.job_id,
            "status": "processing",
            "progress": {
                "percentage": round(progress, 1),
                "stage": stage,
                "stage_progress": round(stage_progress or progress, 1),
                "message": message,
                "elapsed_seconds": round(elapsed, 1),
                "estimated_completion": estimated_completion.isoformat() if estimated_completion else None
            },
            "timestamp": datetime.utcnow().isoformat()
        }

        logger.info(f"Progress update: {self.job_id} - {stage} - {progress}%")

        # Emit progress event via callback
        if self.callback:
            await self.callback(progress_data)

    async def complete(self, result: Dict):
        """Mark job as completed"""
        elapsed = (datetime.utcnow() - self.start_time).total_seconds()

        completion_data = {
            "job_id": self.job_id,
            "status": "completed",
            "progress": {
                "percentage": 100.0,
                "stage": "completed",
                "stage_progress": 100.0,
                "message": "Generation completed successfully",
                "elapsed_seconds": round(elapsed, 1),
                "completed_at": datetime.utcnow().isoformat()
            },
            "result": result,
            "timestamp": datetime.utcnow().isoformat()
        }

        logger.info(f"Job completed: {self.job_id}")

        if self.callback:
            await self.callback(completion_data)

    async def fail(self, error_message: str, stage: str):
        """Mark job as failed"""
        failure_data = {
            "job_id": self.job_id,
            "status": "failed",
            "progress": {
                "percentage": self.current_progress,
                "stage": stage,
                "message": f"Failed at {stage} stage"
            },
            "error": {
                "message": error_message,
                "stage": stage,
                "timestamp": datetime.utcnow().isoformat()
            },
            "timestamp": datetime.utcnow().isoformat()
        }

        logger.error(f"Job failed: {self.job_id} - {error_message}")

        if self.callback:
            await self.callback(failure_data)


# Global progress trackers (in-memory for active jobs)
active_trackers: Dict[str, ProgressTracker] = {}


def get_tracker(job_id: str) -> Optional[ProgressTracker]:
    """Get progress tracker for job"""
    return active_trackers.get(job_id)


def create_tracker(job_id: str, callback: Optional[Callable] = None) -> ProgressTracker:
    """Create new progress tracker"""
    tracker = ProgressTracker(job_id, callback)
    active_trackers[job_id] = tracker
    return tracker


def remove_tracker(job_id: str):
    """Remove progress tracker"""
    if job_id in active_trackers:
        del active_trackers[job_id]
```

**Integration with CrewService (`services/crew_service.py` update):**

```python
from services.progress_service import create_tracker, remove_tracker

async def generate_content(
    self,
    mode: str,
    input_data: dict,
    word_count: int,
    job_id: str,
    progress_callback: Optional[Callable] = None
) -> dict:
    """
    Generate content with progress tracking

    Args:
        mode: Generation mode
        input_data: Mode-specific input data
        word_count: Target word count
        job_id: Job ID for progress tracking
        progress_callback: Callback for progress updates

    Returns:
        Generated content with metadata
    """
    # Create progress tracker
    tracker = create_tracker(job_id, progress_callback)

    try:
        # Stage 1: Research (0-33%)
        await tracker.update("research", 0, "Starting research...", 0)
        research_task = self._create_research_task(mode, input_data)
        await tracker.update("research", 10, "Gathering information...", 30)
        # Execute research
        await tracker.update("research", 33, "Research complete", 100)

        # Stage 2: Writing (33-66%)
        await tracker.update("writing", 33, "Starting article writing...", 0)
        writing_task = self._create_writing_task(mode, input_data, word_count)
        await tracker.update("writing", 45, "Generating content...", 50)
        # Execute writing
        await tracker.update("writing", 66, "Writing complete", 100)

        # Stage 3: SEO Optimization (66-100%)
        await tracker.update("seo", 66, "Optimizing for SEO...", 0)
        seo_task = self._create_seo_task(mode, writing_task)
        await tracker.update("seo", 85, "Analyzing keywords...", 70)
        # Execute SEO
        await tracker.update("seo", 100, "SEO optimization complete", 100)

        result = {
            "content": final_content,
            "meta_title": meta_title,
            "meta_description": meta_description,
            "word_count": word_count,
            "seo_score": seo_score
        }

        # Mark as completed
        await tracker.complete(result)

        return {"success": True, "result": result}

    except Exception as e:
        await tracker.fail(str(e), tracker.current_stage)
        raise
    finally:
        remove_tracker(job_id)
```

**Next.js SSE Endpoint (`app/api/jobs/[id]/progress/route.ts` - NEW):**

```typescript
import { NextRequest } from 'next/server';
import { getServerSession } from 'next-auth';
import { authOptions } from '@/lib/auth';

/**
 * GET /api/jobs/{id}/progress
 * Server-Sent Events stream for real-time job progress
 */
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const session = await getServerSession(authOptions);
  if (!session) {
    return new Response('Unauthorized', { status: 401 });
  }

  const jobId = params.id;

  // Set up SSE headers
  const responseStream = new TransformStream();
  const writer = responseStream.writable.getWriter();
  const encoder = new TextEncoder();

  // Send SSE event
  const sendEvent = (event: string, data: any) => {
    const message = `event: ${event}\ndata: ${JSON.stringify(data)}\n\n`;
    writer.write(encoder.encode(message));
  };

  // Poll MongoDB for progress updates
  const pollProgress = async () => {
    const db = await getDb();

    while (true) {
      const job = await db.collection('generation_jobs').findOne({
        _id: new ObjectId(jobId),
        userId: new ObjectId(session.user.id)
      });

      if (!job) {
        sendEvent('error', { message: 'Job not found' });
        break;
      }

      // Send progress update
      sendEvent('progress', {
        job_id: jobId,
        status: job.status,
        progress: job.progress,
        timestamp: new Date().toISOString()
      });

      // Stop polling if job is completed or failed
      if (['completed', 'failed', 'cancelled'].includes(job.status)) {
        sendEvent('complete', {
          job_id: jobId,
          status: job.status,
          result: job.result || null,
          error: job.error || null
        });
        break;
      }

      // Wait 2 seconds before next poll
      await new Promise(resolve => setTimeout(resolve, 2000));
    }

    writer.close();
  };

  // Start polling in background
  pollProgress().catch(console.error);

  return new Response(responseStream.readable, {
    headers: {
      'Content-Type': 'text/event-stream',
      'Cache-Control': 'no-cache',
      'Connection': 'keep-alive',
    },
  });
}
```

**Frontend Progress Component (`components/generation-progress.tsx` - NEW):**

```typescript
'use client';

import { useEffect, useState } from 'react';
import { Progress } from '@/components/ui/progress';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Loader2 } from 'lucide-react';

interface GenerationProgressProps {
  jobId: string;
  onComplete?: (result: any) => void;
  onError?: (error: any) => void;
}

export function GenerationProgress({ jobId, onComplete, onError }: GenerationProgressProps) {
  const [progress, setProgress] = useState({
    percentage: 0,
    stage: 'queued',
    message: 'Queued for generation...',
    elapsedSeconds: 0,
    estimatedCompletion: null as string | null
  });

  useEffect(() => {
    // Open SSE connection
    const eventSource = new EventSource(`/api/jobs/${jobId}/progress`);

    eventSource.addEventListener('progress', (event) => {
      const data = JSON.parse(event.data);
      setProgress(data.progress);
    });

    eventSource.addEventListener('complete', (event) => {
      const data = JSON.parse(event.data);
      if (data.status === 'completed' && onComplete) {
        onComplete(data.result);
      } else if (data.status === 'failed' && onError) {
        onError(data.error);
      }
      eventSource.close();
    });

    eventSource.addEventListener('error', (event) => {
      console.error('SSE error:', event);
      if (onError) {
        onError({ message: 'Connection error' });
      }
      eventSource.close();
    });

    return () => {
      eventSource.close();
    };
  }, [jobId]);

  const getStageLabel = (stage: string) => {
    switch (stage) {
      case 'research': return 'Researching';
      case 'writing': return 'Writing';
      case 'seo': return 'Optimizing';
      case 'completed': return 'Complete';
      default: return 'Queued';
    }
  };

  return (
    <Card>
      <CardHeader>
        <CardTitle className="flex items-center gap-2">
          <Loader2 className="h-4 w-4 animate-spin" />
          Generating Content
        </CardTitle>
      </CardHeader>
      <CardContent className="space-y-4">
        <div>
          <div className="flex justify-between text-sm mb-2">
            <span>{getStageLabel(progress.stage)}</span>
            <span>{progress.percentage}%</span>
          </div>
          <Progress value={progress.percentage} className="h-2" />
        </div>

        <p className="text-sm text-muted-foreground">{progress.message}</p>

        {progress.estimatedCompletion && (
          <p className="text-xs text-muted-foreground">
            Est. completion: {new Date(progress.estimatedCompletion).toLocaleTimeString()}
          </p>
        )}

        <p className="text-xs text-muted-foreground">
          Elapsed: {Math.floor(progress.elapsedSeconds)}s
        </p>
      </CardContent>
    </Card>
  );
}
```

## Definition of Done

- [ ] ProgressTracker class implemented in FastAPI
- [ ] Progress updates emitted at key stages (research, writing, SEO)
- [ ] Percentage calculation for overall and stage-specific progress
- [ ] Estimated completion time calculation
- [ ] MongoDB job schema updated with progress fields
- [ ] Next.js SSE endpoint `/api/jobs/{id}/progress` created
- [ ] Frontend SSE connection and live UI updates
- [ ] Progress persistence in MongoDB for recovery
- [ ] Bulk job progress tracking (X of Y completed)
- [ ] Error handling and failure detection
- [ ] Tests written for progress tracking
- [ ] Code reviewed and approved
- [ ] Merged to dev branch

## Notes

**Implementation Status**: ⏳ Depends on VIP-10204-10208 (generation workflows)

**Progress Stages:**
1. **Research** (0-33%): Gather information from knowledge base and web
2. **Writing** (33-66%): Generate article content
3. **SEO** (66-100%): Optimize keywords and meta data

**Estimated Times:**
- Topic mode: 2-4 minutes (all 3 stages)
- Keywords mode: 2.5-4 minutes (extra keyword analysis)
- Trends mode: 1-2 minutes (fast model)
- Spin mode: 1-2 minutes (no research stage)

**Server-Sent Events (SSE):**
- One-way communication from server to client
- Automatically reconnects on connection loss
- Lower overhead than WebSockets for one-way updates
- Standard HTTP/HTTPS protocol

**Progress Persistence:**
- All progress stored in MongoDB for recovery
- If server restarts, frontend can resume monitoring
- Historical progress data for analytics

**Bulk Job Progress:**
- Overall: X of Y articles completed
- Current article: Stage and percentage
- Combined progress bar showing both

**Next Stories:**
- VIP-10212: Job Management (retry, cancel, view history)
