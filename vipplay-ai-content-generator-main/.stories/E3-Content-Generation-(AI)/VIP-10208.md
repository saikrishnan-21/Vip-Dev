# VIP-10208: Bulk Content Generation Queue System

**Story ID**: VIP-10208
**Story Type**: Story
**Epic**: E3-Content-Generation-(AI)
**Priority**: High
**Story Points**: 8
**Status**: To Do

## User Story

As a content creator, I want to queue 10-50 articles for generation at once so that I can scale content production efficiently with batch processing

## Acceptance Criteria

- [ ] **AC1**: Accept bulk requests with 10-50 article configurations
- [ ] **AC2**: Queue management system in Next.js MongoDB
- [ ] **AC3**: FastAPI processes one job at a time (sequential, not parallel)
- [ ] **AC4**: Progress tracking for bulk job (X of Y completed)
- [ ] **AC5**: Bulk job can be paused, resumed, or cancelled
- [ ] **AC6**: Failed individual articles don't stop the bulk job
- [ ] **AC7**: Notification when bulk job completes

## Technical Details

**Architecture:**
- **FastAPI Role**: Process individual article generation requests sequentially
- **Next.js Role**: Create bulk job in MongoDB, queue individual jobs, track progress, send notifications
- **Queue System**: MongoDB-based job queue with status tracking

**Bulk Generation Workflow:**

```
User Input (Next.js):
- bulk_config: {
    mode: "topic" | "keywords" | "trends" | "spin",
    items: [
      { topic: "Article 1", word_count: 1500, tone: "professional" },
      { topic: "Article 2", word_count: 1200, tone: "casual" },
      // ... up to 50 items
    ]
  }
    ↓
Next.js creates bulk_job in MongoDB:
{
  _id: ObjectId,
  userId: "...",
  status: "queued",
  total_items: 50,
  completed_items: 0,
  failed_items: 0,
  created_at: Date,
  started_at: null,
  completed_at: null
}
    ↓
Next.js creates 50 individual generation_jobs:
{
  _id: ObjectId,
  bulk_job_id: "...",
  userId: "...",
  mode: "topic",
  topic: "Article 1",
  word_count: 1500,
  status: "queued",
  queue_position: 1
}
    ↓
Next.js Background Worker processes queue:
- Pick next "queued" job
- Call FastAPI /api/content/generate/{mode}
- Wait for completion
- Update bulk_job progress
- Move to next job
    ↓
When all complete:
- Update bulk_job status: "completed"
- Send notification to user
```

**MongoDB Collections:**

```typescript
// bulk_jobs collection
interface BulkJob {
  _id: ObjectId;
  userId: ObjectId;
  mode: "topic" | "keywords" | "trends" | "spin";
  total_items: number;
  completed_items: number;
  failed_items: number;
  status: "queued" | "processing" | "paused" | "completed" | "cancelled";
  created_at: Date;
  started_at: Date | null;
  completed_at: Date | null;
  estimated_completion: Date | null;
  error_summary: string[];
}

// generation_jobs collection (existing, enhanced)
interface GenerationJob {
  _id: ObjectId;
  bulk_job_id: ObjectId | null;  // NEW: Link to bulk job
  userId: ObjectId;
  mode: string;
  // ... existing fields ...
  queue_position: number | null;  // NEW: Position in bulk queue
  retry_count: number;            // NEW: Retry attempts
}
```

**Next.js Background Worker (`lib/queue-worker.ts` - NEW):**

```typescript
/**
 * Background worker for processing bulk generation queue
 * Runs as Next.js API route with long-polling or cron job
 */

import { ObjectId } from 'mongodb';
import { getDb } from '@/lib/mongodb';

export class BulkGenerationWorker {
  private isRunning = false;
  private currentJobId: ObjectId | null = null;

  async start() {
    if (this.isRunning) return;
    this.isRunning = true;

    while (this.isRunning) {
      await this.processNextJob();
      await new Promise(resolve => setTimeout(resolve, 5000)); // 5 sec delay
    }
  }

  async processNextJob() {
    const db = await getDb();

    // Find next queued job (FIFO)
    const job = await db.collection('generation_jobs').findOne({
      status: 'queued',
      bulk_job_id: { $ne: null }
    }, {
      sort: { queue_position: 1, created_at: 1 }
    });

    if (!job) return; // No jobs in queue

    try {
      this.currentJobId = job._id;

      // Update job status
      await db.collection('generation_jobs').updateOne(
        { _id: job._id },
        { $set: { status: 'processing', started_at: new Date() } }
      );

      // Call FastAPI
      const response = await fetch(`${process.env.FASTAPI_URL}/api/content/generate/${job.mode}`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          mode: job.mode,
          // ... job parameters ...
          job_id: job._id.toString(),
          user_id: job.userId.toString()
        })
      });

      const result = await response.json();

      if (result.success) {
        // Mark job as completed
        await db.collection('generation_jobs').updateOne(
          { _id: job._id },
          {
            $set: {
              status: 'completed',
              completed_at: new Date(),
              result: result.content
            }
          }
        );

        // Update bulk job progress
        await db.collection('bulk_jobs').updateOne(
          { _id: job.bulk_job_id },
          {
            $inc: { completed_items: 1 },
            $set: { status: 'processing' }
          }
        );

      } else {
        // Mark job as failed
        await db.collection('generation_jobs').updateOne(
          { _id: job._id },
          {
            $set: {
              status: 'failed',
              error: result.error,
              completed_at: new Date()
            },
            $inc: { retry_count: 1 }
          }
        );

        // Update bulk job failed count
        await db.collection('bulk_jobs').updateOne(
          { _id: job.bulk_job_id },
          { $inc: { failed_items: 1 } }
        );
      }

      // Check if bulk job is complete
      const bulkJob = await db.collection('bulk_jobs').findOne({ _id: job.bulk_job_id });
      if (bulkJob && (bulkJob.completed_items + bulkJob.failed_items) >= bulkJob.total_items) {
        await db.collection('bulk_jobs').updateOne(
          { _id: bulkJob._id },
          {
            $set: {
              status: 'completed',
              completed_at: new Date()
            }
          }
        );

        // Send notification
        await this.sendCompletionNotification(bulkJob);
      }

    } catch (error) {
      console.error('Job processing error:', error);

      // Mark job as failed
      await db.collection('generation_jobs').updateOne(
        { _id: job._id },
        {
          $set: {
            status: 'failed',
            error: error.message
          },
          $inc: { retry_count: 1 }
        }
      );
    }

    this.currentJobId = null;
  }

  async pause() {
    this.isRunning = false;
  }

  async sendCompletionNotification(bulkJob: any) {
    // TODO: Implement email notification (VIP-10605)
    console.log(`Bulk job ${bulkJob._id} completed:`, {
      total: bulkJob.total_items,
      completed: bulkJob.completed_items,
      failed: bulkJob.failed_items
    });
  }
}

// Singleton instance
export const bulkWorker = new BulkGenerationWorker();
```

**Next.js API Routes:**

```typescript
// app/api/bulk-generate/route.ts
export async function POST(request: NextRequest) {
  const session = await getServerSession(authOptions);
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  const { mode, items } = await request.json();

  // Validate bulk request
  if (!items || items.length < 10 || items.length > 50) {
    return NextResponse.json({
      error: 'Bulk generation requires 10-50 items'
    }, { status: 400 });
  }

  const db = await getDb();

  // Create bulk job
  const bulkJob = await db.collection('bulk_jobs').insertOne({
    userId: new ObjectId(session.user.id),
    mode,
    total_items: items.length,
    completed_items: 0,
    failed_items: 0,
    status: 'queued',
    created_at: new Date(),
    started_at: null,
    completed_at: null
  });

  // Create individual jobs
  const jobs = items.map((item, index) => ({
    bulk_job_id: bulkJob.insertedId,
    userId: new ObjectId(session.user.id),
    mode,
    ...item,
    status: 'queued',
    queue_position: index + 1,
    retry_count: 0,
    created_at: new Date()
  }));

  await db.collection('generation_jobs').insertMany(jobs);

  // Start worker if not running
  bulkWorker.start().catch(console.error);

  return NextResponse.json({
    success: true,
    bulk_job_id: bulkJob.insertedId.toString(),
    total_items: items.length,
    message: 'Bulk generation queued'
  });
}

// app/api/bulk-generate/[id]/route.ts - Get bulk job status
export async function GET(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const db = await getDb();

  const bulkJob = await db.collection('bulk_jobs').findOne({
    _id: new ObjectId(params.id)
  });

  if (!bulkJob) {
    return NextResponse.json({ error: 'Bulk job not found' }, { status: 404 });
  }

  // Get individual job statuses
  const jobs = await db.collection('generation_jobs')
    .find({ bulk_job_id: bulkJob._id })
    .sort({ queue_position: 1 })
    .toArray();

  return NextResponse.json({
    bulk_job: bulkJob,
    jobs: jobs.map(j => ({
      id: j._id,
      status: j.status,
      queue_position: j.queue_position,
      error: j.error || null
    })),
    progress: {
      total: bulkJob.total_items,
      completed: bulkJob.completed_items,
      failed: bulkJob.failed_items,
      remaining: bulkJob.total_items - (bulkJob.completed_items + bulkJob.failed_items),
      percentage: Math.round((bulkJob.completed_items / bulkJob.total_items) * 100)
    }
  });
}

// app/api/bulk-generate/[id]/pause/route.ts
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const db = await getDb();

  await db.collection('bulk_jobs').updateOne(
    { _id: new ObjectId(params.id) },
    { $set: { status: 'paused' } }
  );

  return NextResponse.json({ success: true, message: 'Bulk job paused' });
}

// app/api/bulk-generate/[id]/cancel/route.ts
export async function POST(
  request: NextRequest,
  { params }: { params: { id: string } }
) {
  const db = await getDb();

  // Cancel bulk job
  await db.collection('bulk_jobs').updateOne(
    { _id: new ObjectId(params.id) },
    { $set: { status: 'cancelled', completed_at: new Date() } }
  );

  // Cancel all queued individual jobs
  await db.collection('generation_jobs').updateMany(
    { bulk_job_id: new ObjectId(params.id), status: 'queued' },
    { $set: { status: 'cancelled' } }
  );

  return NextResponse.json({ success: true, message: 'Bulk job cancelled' });
}
```

**FastAPI Changes:**
- No changes needed! FastAPI continues to process individual jobs
- Next.js handles bulk orchestration and queuing

## Definition of Done

- [ ] MongoDB bulk_jobs collection schema defined
- [ ] MongoDB generation_jobs collection enhanced with bulk fields
- [ ] BulkGenerationWorker implemented with sequential processing
- [ ] Next.js API route for bulk generation (`/api/bulk-generate`)
- [ ] Bulk job status endpoint (`/api/bulk-generate/[id]`)
- [ ] Pause/resume bulk job endpoints
- [ ] Cancel bulk job endpoint
- [ ] Progress tracking accurate (X of Y completed)
- [ ] Failed jobs don't stop bulk processing
- [ ] Completion notification sent
- [ ] Tests written for bulk workflow
- [ ] Code reviewed and approved
- [ ] Merged to dev branch

## Notes

**Implementation Status**: ⏳ Depends on VIP-10204-10207 (generation modes), VIP-10211 (job management)

**Bulk Generation Characteristics:**
- **Queue Size**: 10-50 articles per bulk job
- **Processing**: Sequential (one at a time, no parallelization)
- **Failure Handling**: Continue processing even if individual jobs fail
- **Progress Tracking**: Real-time updates in MongoDB
- **Estimated Time**: 2-4 minutes per article × 50 = 100-200 minutes max

**Performance Considerations:**
- Sequential processing prevents FastAPI overload
- 5-second delay between jobs prevents throttling
- Long-running Next.js API route or separate worker process
- Consider implementing with Next.js Edge Functions or external worker

**Queue Management:**
- FIFO (First In First Out) processing
- Queue position determines processing order
- Paused jobs skip processing until resumed
- Cancelled jobs removed from queue

**Error Handling:**
- Individual job failures recorded but don't stop bulk job
- Retry logic: up to 2 retries for failed jobs
- Error summary included in bulk job completion notification

**Future Enhancements:**
- Parallel processing (2-3 concurrent jobs)
- Priority queue (premium users first)
- Scheduled bulk generation (cron jobs)
- Bulk templates for repeated workflows

**Next Stories:**
- VIP-10211: Progress tracking (real-time updates for bulk and individual jobs)
- VIP-10212: Job management (view, retry, cancel individual jobs)
